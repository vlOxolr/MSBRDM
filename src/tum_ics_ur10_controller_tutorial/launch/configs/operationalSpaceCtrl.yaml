operational_space_ctrl:
  enable_safe: true
  enable_move: true
  enable_draw: true

  safe_tol: 0.06
  q_safe: [0.001, -0.8998, 1.2470, -1.9591, -1.56276, 0.8]  # q_safe: [0, -0.7, 0.7, -1, 0.3, 1]

  Kp_safe: [5,  1, 1, 0.2, 0.2, 1]
  Kd_safe: [5, 30, 40, 10, 10, 5]

  Kp_pos: [15, 15, 15]
  Kp_ori: [10, 10, 20]
  Kd:      [12, 12, 8, 4, 4, 4]  #DRAW phase: tau = -Kd_ * s + Y * theta_hat_;

  tau_max: 90.0
  qdot_r_max: 2.0
  xdot_r_max: 0.25
  wdot_r_max: 0.80

  adaptive:
    enabled: true
    gamma: 0.5
    sigma: 0.02
    theta_hat_max: 200.0

  pixel_to_world:
    scale_x:  0.0002  # meters per pixel-col → world X (negative to flip)
    scale_y: -0.0002  # meters per pixel-row → world Y (negative: image-down → world-up)
    offset_x: 1.1    # world X offset (meters)
    offset_y: 0.339   # world Y offset (meters), tuned to keep first goal y near -0.65
    rotation_deg: 90.0  # CW rotation about z-axis (degrees), 0=no rotation

  move:
    time: 20.0
    speed: 0.0         # m/s, <=0 means use move.time
    pos_tol: 0.01      # meters, position tolerance for early MOVE→DRAW switch
    ori_tol: 0.35      # radians, orientation tolerance for early MOVE→DRAW switch

  draw:
    time: 20.0
    speed: 0.0         # m/s, <=0 means use draw.time or length_world/speed
    use_fixed_z: true
    fixed_z: 0.0805
    blend_ratio: 0.1   # fraction of T_draw for velocity ramp-up at DRAW start
    force_target_z: 20.0   # desired contact force [N]
    force_z_sign: 1.0      # effective Fz = force_z_sign * raw_Fz; set -1.0 if sign is opposite
    force_k_i_z: 0.00015     # integral gain [m/(N*s)]

  trajectory:
    topic: /ur10/planar_polynomial_trajectories  # std_msgs/String XML
